// Autogenerated from Pigeon (v25.5.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import CoreLocation
import Contacts

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol CLGeocoderLibraryPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class CLGeocoderLibraryPigeonInternalFinalizer {
  internal static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  internal weak var delegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate
  ) {
    let finalizer = CLGeocoderLibraryPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    let finalizer = objc_getAssociatedObject(instance, associatedObjectKey) as? CLGeocoderLibraryPigeonInternalFinalizer
    if let finalizer = finalizer {
      finalizer.delegate = nil
      objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
    }
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`CLGeocoderLibraryPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class CLGeocoderLibraryPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "CLGeocoderLibraryPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    CLGeocoderLibraryPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `CLGeocoderLibraryPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      let weakInstancesEnumerator = weakInstances.objectEnumerator()!
      while let instance = weakInstancesEnumerator.nextObject() {
        CLGeocoderLibraryPigeonInternalFinalizer.detach(from: instance as AnyObject)
      }
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = CLGeocoderLibraryPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class CLGeocoderLibraryPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { CLGeocoderLibraryPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `CLGeocoderLibraryPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: CLGeocoderLibraryPigeonInstanceManager?) {
    let codec = CLGeocoderLibraryPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.geocoding_darwin.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol CLGeocoderLibraryPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiCLFloor] used to add a new Dart instance of
  /// `CLFloor` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLFloor(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLFloor
  /// An implementation of [PigeonApiCLGeocoder] used to add a new Dart instance of
  /// `CLGeocoder` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLGeocoder(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLGeocoder
  /// An implementation of [PigeonApiCLLocation] used to add a new Dart instance of
  /// `CLLocation` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLLocation(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLLocation
  /// An implementation of [PigeonApiCLLocationCoordinate2D] used to add a new Dart instance of
  /// `CLLocationCoordinate2D` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLLocationCoordinate2D(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLLocationCoordinate2D
  /// An implementation of [PigeonApiCLLocationSourceInformation] used to add a new Dart instance of
  /// `CLLocationSourceInformation` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLLocationSourceInformation(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLLocationSourceInformation
  /// An implementation of [PigeonApiCLPlacemark] used to add a new Dart instance of
  /// `CLPlacemark` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCLPlacemark(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCLPlacemark
  /// An implementation of [PigeonApiCNPostalAddress] used to add a new Dart instance of
  /// `CNPostalAddress` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiCNPostalAddress(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiCNPostalAddress
  /// An implementation of [PigeonApiLocale] used to add a new Dart instance of
  /// `Locale` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiLocale(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiLocale
  /// An implementation of [PigeonApiNSObject] used to add a new Dart instance of
  /// `NSObject` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSObject(_ registrar: CLGeocoderLibraryPigeonProxyApiRegistrar) -> PigeonApiNSObject
}

open class CLGeocoderLibraryPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: CLGeocoderLibraryPigeonProxyApiDelegate
  let instanceManager: CLGeocoderLibraryPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: CLGeocoderLibraryPigeonInternalFinalizerDelegate {
    let api: CLGeocoderLibraryPigeonInstanceManagerApi

    init(_ api: CLGeocoderLibraryPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: CLGeocoderLibraryPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = CLGeocoderLibraryPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        CLGeocoderLibraryPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    CLGeocoderLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiCLGeocoder.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCLGeocoder(self))
    PigeonApiCLLocation.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiCLLocation(self))
    PigeonApiLocale.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiLocale(self))
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSObject(self))
  }
  func tearDown() {
    CLGeocoderLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiCLGeocoder.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiCLLocation.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiLocale.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar

  private class CLGeocoderLibraryPigeonInternalProxyApiCodecReader: CLGeocoderLibraryPigeonCodecReader {
    unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class CLGeocoderLibraryPigeonInternalProxyApiCodecWriter: CLGeocoderLibraryPigeonCodecWriter {
    unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is KeyValueObservingOptions || value is KeyValueChange || value is KeyValueChangeKey {
        super.writeValue(value)
        return
      }


      if let instance = value as? CLFloor {
        pigeonRegistrar.apiDelegate.pigeonApiCLFloor(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLGeocoder {
        pigeonRegistrar.apiDelegate.pigeonApiCLGeocoder(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLLocation {
        pigeonRegistrar.apiDelegate.pigeonApiCLLocation(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLLocationCoordinate2DWrapper {
        pigeonRegistrar.apiDelegate.pigeonApiCLLocationCoordinate2D(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if #available(iOS 15.0.0, macOS 12.0.0, *), let instance = value as? CLLocationSourceInformation {
        pigeonRegistrar.apiDelegate.pigeonApiCLLocationSourceInformation(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CLPlacemark {
        pigeonRegistrar.apiDelegate.pigeonApiCLPlacemark(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? CNPostalAddress {
        pigeonRegistrar.apiDelegate.pigeonApiCNPostalAddress(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? LocaleWrapper {
        pigeonRegistrar.apiDelegate.pigeonApiLocale(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSObject {
        pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for CLGeocoderLibraryPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return CLGeocoderLibraryPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CLGeocoderLibraryPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

/// The values that can be returned in a change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions.
enum KeyValueObservingOptions: Int {
  /// Indicates that the change dictionary should provide the new attribute
  /// value, if applicable.
  case newValue = 0
  /// Indicates that the change dictionary should contain the old attribute
  /// value, if applicable.
  case oldValue = 1
  /// If specified, a notification should be sent to the observer immediately,
  /// before the observer registration method even returns.
  case initialValue = 2
  /// Whether separate notifications should be sent to the observer before and
  /// after each change, instead of a single notification after the change.
  case priorNotification = 3
}

/// The kinds of changes that can be observed.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechange.
enum KeyValueChange: Int {
  /// Indicates that the value of the observed key path was set to a new value.
  case setting = 0
  /// Indicates that an object has been inserted into the to-many relationship
  /// that is being observed.
  case insertion = 1
  /// Indicates that an object has been removed from the to-many relationship
  /// that is being observed.
  case removal = 2
  /// Indicates that an object has been replaced in the to-many relationship
  /// that is being observed.
  case replacement = 3
  /// The value is not recognized by the wrapper.
  case unknown = 4
}

/// The keys that can appear in the change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechangekey.
enum KeyValueChangeKey: Int {
  /// If the value of the `KeyValueChangeKey.kind` entry is
  /// `KeyValueChange.insertion`, `KeyValueChange.removal`, or
  /// `KeyValueChange.replacement`, the value of this key is a Set object that
  /// contains the indexes of the inserted, removed, or replaced objects.
  case indexes = 0
  /// An object that contains a value corresponding to one of the
  /// `KeyValueChange` enum, indicating what sort of change has occurred.
  case kind = 1
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting, and `KeyValueObservingOptions.newValue` was
  /// specified when the observer was registered, the value of this key is the
  /// new value for the attribute.
  case newValue = 2
  /// If the `KeyValueObservingOptions.priorNotification` option was specified
  /// when the observer was registered this notification is sent prior to a
  /// change.
  case notificationIsPrior = 3
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting`, and `KeyValueObservingOptions.old` was specified
  /// when the observer was registered, the value of this key is the value
  /// before the attribute was changed.
  case oldValue = 4
  /// The value is not recognized by the wrapper.
  case unknown = 5
}

private class CLGeocoderLibraryPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueObservingOptions(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChange(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChangeKey(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CLGeocoderLibraryPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? KeyValueObservingOptions {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChange {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChangeKey {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class CLGeocoderLibraryPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CLGeocoderLibraryPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CLGeocoderLibraryPigeonCodecWriter(data: data)
  }
}

class CLGeocoderLibraryPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = CLGeocoderLibraryPigeonCodec(readerWriter: CLGeocoderLibraryPigeonCodecReaderWriter())
}

protocol PigeonApiDelegateCLFloor {
  /// The logical floor of the building.
  func level(pigeonApi: PigeonApiCLFloor, pigeonInstance: CLFloor) throws -> Int64
}

protocol PigeonApiProtocolCLFloor {
}

final class PigeonApiCLFloor: PigeonApiProtocolCLFloor  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLFloor
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLFloor) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CLFloor and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLFloor, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let levelArg = try! pigeonDelegate.level(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLFloor.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, levelArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLGeocoder {
  /// Creates a [CLGeocoder].
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCLGeocoder) throws -> CLGeocoder
  /// Submits a forward-geocoding requesting using the specified address string
  /// and locale information.
  func geocodeAddressString(pigeonApi: PigeonApiCLGeocoder, pigeonInstance: CLGeocoder, address: String, locale: LocaleWrapper?, completion: @escaping (Result<[CLPlacemark]?, Error>) -> Void)
  /// Submits a forward-geocoding requesting using the specified locale and
  /// Contacts framework information.
  func geocodePostalAddress(pigeonApi: PigeonApiCLGeocoder, pigeonInstance: CLGeocoder, postalAddress: CNPostalAddress, locale: LocaleWrapper?, completion: @escaping (Result<[CLPlacemark]?, Error>) -> Void)
  /// Submits a reverse-geocoding request for the specified location.
  func reverseGeocodeLocation(pigeonApi: PigeonApiCLGeocoder, pigeonInstance: CLGeocoder, location: CLLocation, locale: LocaleWrapper?, completion: @escaping (Result<[CLPlacemark]?, Error>) -> Void)
}

protocol PigeonApiProtocolCLGeocoder {
}

final class PigeonApiCLGeocoder: PigeonApiProtocolCLGeocoder  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLGeocoder
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLGeocoder) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCLGeocoder?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLGeocoder.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let geocodeAddressStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLGeocoder.geocodeAddressString", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      geocodeAddressStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLGeocoder
        let addressArg = args[1] as! String
        let localeArg: LocaleWrapper? = nilOrValue(args[2])
        api.pigeonDelegate.geocodeAddressString(pigeonApi: api, pigeonInstance: pigeonInstanceArg, address: addressArg, locale: localeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      geocodeAddressStringChannel.setMessageHandler(nil)
    }
    let geocodePostalAddressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLGeocoder.geocodePostalAddress", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      geocodePostalAddressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLGeocoder
        let postalAddressArg = args[1] as! CNPostalAddress
        let localeArg: LocaleWrapper? = nilOrValue(args[2])
        api.pigeonDelegate.geocodePostalAddress(pigeonApi: api, pigeonInstance: pigeonInstanceArg, postalAddress: postalAddressArg, locale: localeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      geocodePostalAddressChannel.setMessageHandler(nil)
    }
    let reverseGeocodeLocationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLGeocoder.reverseGeocodeLocation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reverseGeocodeLocationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLGeocoder
        let locationArg = args[1] as! CLLocation
        let localeArg: LocaleWrapper? = nilOrValue(args[2])
        api.pigeonDelegate.reverseGeocodeLocation(pigeonApi: api, pigeonInstance: pigeonInstanceArg, location: locationArg, locale: localeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      reverseGeocodeLocationChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CLGeocoder and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLGeocoder, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLGeocoder.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLLocation {
  /// Creates a [CLLocation] based on the supplied coordinates.
  func pigeonDefaultConstructor(pigeonApi: PigeonApiCLLocation, latitude: Double, longitude: Double) throws -> CLLocation
  /// The geographical coordinate information.
  func getCoordinate(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> CLLocationCoordinate2DWrapper
  /// The altitude above mean sea level associated with a location, measured in
  /// meters.
  func getAltitude(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The altitude as a height above the World Geodetic System 1984 (WGS84)
  /// ellipsoid, measured in meters.
  func getEllipsoidalAltitude(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The logical floor of the building in which the user is located.
  func getFloor(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> CLFloor?
  /// The time at which this location was determined (in seconds since epoch).
  func getTimestamp(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Int64
  /// Information about the source that provides the location.
  @available(iOS 15.0.0, macOS 12.0.0, *)
  func getSourceInformation(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> CLLocationSourceInformation?
  /// The radius of uncertainty for the location, measured in meters.
  func getHorizontalAccuracy(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The validity of the altitude values, and their estimated uncertainty,
  /// measured in meters.
  func getVerticalAccuracy(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The instantaneous speed of the device, measured in meters per second.
  func getSpeed(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The accuracy of the speed value, measured in meters per second.
  func getSpeedAccuracy(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The direction in which the device is traveling, measured in degrees and
  /// relative to due north.
  func getCourse(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// The accuracy of the course value, measured in degrees.
  func getCourseAccuracy(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation) throws -> Double
  /// Returns the distance (measured in meters) from the current objectâ€™s
  /// location to the specified location.
  func distance(pigeonApi: PigeonApiCLLocation, pigeonInstance: CLLocation, from: CLLocation) throws -> Double
}

protocol PigeonApiProtocolCLLocation {
}

final class PigeonApiCLLocation: PigeonApiProtocolCLLocation  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLLocation
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLLocation) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiCLLocation?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let latitudeArg = args[1] as! Double
        let longitudeArg = args[2] as! Double
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, latitude: latitudeArg, longitude: longitudeArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getCoordinateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getCoordinate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCoordinateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getCoordinate(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCoordinateChannel.setMessageHandler(nil)
    }
    let getAltitudeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getAltitude", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAltitudeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getAltitude(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAltitudeChannel.setMessageHandler(nil)
    }
    let getEllipsoidalAltitudeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getEllipsoidalAltitude", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEllipsoidalAltitudeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getEllipsoidalAltitude(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getEllipsoidalAltitudeChannel.setMessageHandler(nil)
    }
    let getFloorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getFloor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFloorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getFloor(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFloorChannel.setMessageHandler(nil)
    }
    let getTimestampChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getTimestamp", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTimestampChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getTimestamp(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTimestampChannel.setMessageHandler(nil)
    }
    if #available(iOS 15.0.0, macOS 12.0.0, *) {
      let getSourceInformationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getSourceInformation", binaryMessenger: binaryMessenger, codec: codec)
      if let api = api {
        getSourceInformationChannel.setMessageHandler { message, reply in
          let args = message as! [Any?]
          let pigeonInstanceArg = args[0] as! CLLocation
          do {
            let result = try api.pigeonDelegate.getSourceInformation(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
            reply(wrapResult(result))
          } catch {
            reply(wrapError(error))
          }
        }
      } else {
        getSourceInformationChannel.setMessageHandler(nil)
      }
    }     else {
      let getSourceInformationChannel = FlutterBasicMessageChannel(
        name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getSourceInformation",
        binaryMessenger: binaryMessenger, codec: codec)
      if api != nil {
        getSourceInformationChannel.setMessageHandler { message, reply in
          reply(wrapError(FlutterError(code: "PigeonUnsupportedOperationError",
                                       message: "Call to getSourceInformation requires @available(iOS 15.0.0, macOS 12.0.0, *).",
                                       details: nil
                                      )))
        }
      } else {
        getSourceInformationChannel.setMessageHandler(nil)
      }
    }
    let getHorizontalAccuracyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getHorizontalAccuracy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHorizontalAccuracyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getHorizontalAccuracy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHorizontalAccuracyChannel.setMessageHandler(nil)
    }
    let getVerticalAccuracyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getVerticalAccuracy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVerticalAccuracyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getVerticalAccuracy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVerticalAccuracyChannel.setMessageHandler(nil)
    }
    let getSpeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getSpeed", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getSpeed(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpeedChannel.setMessageHandler(nil)
    }
    let getSpeedAccuracyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getSpeedAccuracy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpeedAccuracyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getSpeedAccuracy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpeedAccuracyChannel.setMessageHandler(nil)
    }
    let getCourseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getCourse", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCourseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getCourse(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCourseChannel.setMessageHandler(nil)
    }
    let getCourseAccuracyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.getCourseAccuracy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCourseAccuracyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        do {
          let result = try api.pigeonDelegate.getCourseAccuracy(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCourseAccuracyChannel.setMessageHandler(nil)
    }
    let distanceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.CLLocation.distance", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      distanceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! CLLocation
        let fromArg = args[1] as! CLLocation
        do {
          let result = try api.pigeonDelegate.distance(pigeonApi: api, pigeonInstance: pigeonInstanceArg, from: fromArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      distanceChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of CLLocation and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLLocation, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLLocation.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLLocationCoordinate2D {
  /// The latitude in degrees.
  func latitude(pigeonApi: PigeonApiCLLocationCoordinate2D, pigeonInstance: CLLocationCoordinate2DWrapper) throws -> Double
  /// The longitude in degrees.
  func longitude(pigeonApi: PigeonApiCLLocationCoordinate2D, pigeonInstance: CLLocationCoordinate2DWrapper) throws -> Double
}

protocol PigeonApiProtocolCLLocationCoordinate2D {
}

final class PigeonApiCLLocationCoordinate2D: PigeonApiProtocolCLLocationCoordinate2D  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLLocationCoordinate2D
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLLocationCoordinate2D) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CLLocationCoordinate2D and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLLocationCoordinate2DWrapper, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let latitudeArg = try! pigeonDelegate.latitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let longitudeArg = try! pigeonDelegate.longitude(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLLocationCoordinate2D.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, latitudeArg, longitudeArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLLocationSourceInformation {
  /// A Boolean value that indicates whether the system receives the location
  /// from an external accessory.
  @available(iOS 15.0.0, macOS 12.0.0, *)
  func isProducedByAccessory(pigeonApi: PigeonApiCLLocationSourceInformation, pigeonInstance: CLLocationSourceInformation) throws -> Bool
  /// A Boolean value that indicates whether the system generates the location
  /// using on-device software simulation.
  @available(iOS 15.0.0, macOS 12.0.0, *)
  func isSimulatedBySoftware(pigeonApi: PigeonApiCLLocationSourceInformation, pigeonInstance: CLLocationSourceInformation) throws -> Bool
}

protocol PigeonApiProtocolCLLocationSourceInformation {
}

final class PigeonApiCLLocationSourceInformation: PigeonApiProtocolCLLocationSourceInformation  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLLocationSourceInformation
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLLocationSourceInformation) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CLLocationSourceInformation and attaches it to [pigeonInstance].
  @available(iOS 15.0.0, macOS 12.0.0, *)
  func pigeonNewInstance(pigeonInstance: CLLocationSourceInformation, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let isProducedByAccessoryArg = try! pigeonDelegate.isProducedByAccessory(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isSimulatedBySoftwareArg = try! pigeonDelegate.isSimulatedBySoftware(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLLocationSourceInformation.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, isProducedByAccessoryArg, isSimulatedBySoftwareArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCLPlacemark {
  /// The [CLLocation] containing latitude and longitude information.
  func location(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> CLLocation?
  /// The name of the placemark.
  func name(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The street address associated with the placemark.
  func thoroughfare(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// Additional street-level information for the placemark.
  func subThoroughfare(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The city associated with the placemark.
  func locality(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// Additional city-level information for the placemark.
  func subLocality(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The state or province associated with the placemark.
  func administrativeArea(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// Additional administrative area information for the placemark.
  func subAdministrativeArea(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The postal code associated with the placemark.
  func postalCode(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The abbreviated country or region name.
  func isoCountryCode(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The name of the country or region associated with the placemark.
  func country(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> String?
  /// The postal address associated with the location, formatted for use with the Contacts framework.
  func postalAddress(pigeonApi: PigeonApiCLPlacemark, pigeonInstance: CLPlacemark) throws -> CNPostalAddress?
}

protocol PigeonApiProtocolCLPlacemark {
}

final class PigeonApiCLPlacemark: PigeonApiProtocolCLPlacemark  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCLPlacemark
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCLPlacemark) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CLPlacemark and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CLPlacemark, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let locationArg = try! pigeonDelegate.location(pigeonApi: self, pigeonInstance: pigeonInstance)
      let nameArg = try! pigeonDelegate.name(pigeonApi: self, pigeonInstance: pigeonInstance)
      let thoroughfareArg = try! pigeonDelegate.thoroughfare(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subThoroughfareArg = try! pigeonDelegate.subThoroughfare(pigeonApi: self, pigeonInstance: pigeonInstance)
      let localityArg = try! pigeonDelegate.locality(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subLocalityArg = try! pigeonDelegate.subLocality(pigeonApi: self, pigeonInstance: pigeonInstance)
      let administrativeAreaArg = try! pigeonDelegate.administrativeArea(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subAdministrativeAreaArg = try! pigeonDelegate.subAdministrativeArea(pigeonApi: self, pigeonInstance: pigeonInstance)
      let postalCodeArg = try! pigeonDelegate.postalCode(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isoCountryCodeArg = try! pigeonDelegate.isoCountryCode(pigeonApi: self, pigeonInstance: pigeonInstance)
      let countryArg = try! pigeonDelegate.country(pigeonApi: self, pigeonInstance: pigeonInstance)
      let postalAddressArg = try! pigeonDelegate.postalAddress(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CLPlacemark.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, locationArg, nameArg, thoroughfareArg, subThoroughfareArg, localityArg, subLocalityArg, administrativeAreaArg, subAdministrativeAreaArg, postalCodeArg, isoCountryCodeArg, countryArg, postalAddressArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateCNPostalAddress {
  /// The street name in a postal address.
  func street(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The city name in a postal address.
  func city(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The state name in a postal address.
  func state(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The postal code in a postal address.
  func postalCode(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The country or region name in a postal address.
  func country(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The ISO country code for the country or region in a postal address, using
  /// the ISO 3166-1 alpha-2 standard.
  func isoCountryCode(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// The subadministrative area (such as a county or other region) in a postal
  /// address.
  func subAdministrativeArea(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
  /// Additional information associated with the location, typically defined at
  /// the city or town level, in a postal address.
  func subLocality(pigeonApi: PigeonApiCNPostalAddress, pigeonInstance: CNPostalAddress) throws -> String
}

protocol PigeonApiProtocolCNPostalAddress {
}

final class PigeonApiCNPostalAddress: PigeonApiProtocolCNPostalAddress  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateCNPostalAddress
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateCNPostalAddress) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of CNPostalAddress and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: CNPostalAddress, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let streetArg = try! pigeonDelegate.street(pigeonApi: self, pigeonInstance: pigeonInstance)
      let cityArg = try! pigeonDelegate.city(pigeonApi: self, pigeonInstance: pigeonInstance)
      let stateArg = try! pigeonDelegate.state(pigeonApi: self, pigeonInstance: pigeonInstance)
      let postalCodeArg = try! pigeonDelegate.postalCode(pigeonApi: self, pigeonInstance: pigeonInstance)
      let countryArg = try! pigeonDelegate.country(pigeonApi: self, pigeonInstance: pigeonInstance)
      let isoCountryCodeArg = try! pigeonDelegate.isoCountryCode(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subAdministrativeAreaArg = try! pigeonDelegate.subAdministrativeArea(pigeonApi: self, pigeonInstance: pigeonInstance)
      let subLocalityArg = try! pigeonDelegate.subLocality(pigeonApi: self, pigeonInstance: pigeonInstance)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.CNPostalAddress.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg, streetArg, cityArg, stateArg, postalCodeArg, countryArg, isoCountryCodeArg, subAdministrativeAreaArg, subLocalityArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateLocale {
  /// Creates a [Locale] matching the given identifier.
  func pigeonDefaultConstructor(pigeonApi: PigeonApiLocale, identifier: String) throws -> LocaleWrapper
  /// The identifier of the locale.
  func getIdentifier(pigeonApi: PigeonApiLocale, pigeonInstance: LocaleWrapper) throws -> String
}

protocol PigeonApiProtocolLocale {
}

final class PigeonApiLocale: PigeonApiProtocolLocale  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateLocale
  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateLocale) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiLocale?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.Locale.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let identifierArg = args[1] as! String
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, identifier: identifierArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getIdentifierChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.Locale.getIdentifier", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIdentifierChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! LocaleWrapper
        do {
          let result = try api.pigeonDelegate.getIdentifier(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getIdentifierChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of Locale and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: LocaleWrapper, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.Locale.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
protocol PigeonApiDelegateNSObject {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiNSObject) throws -> NSObject
  /// Registers the observer object to receive KVO notifications for the key
  /// path relative to the object receiving this message.
  func addObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, observer: NSObject, keyPath: String, options: [KeyValueObservingOptions]) throws
  /// Stops the observer object from receiving change notifications for the
  /// property specified by the key path relative to the object receiving this
  /// message.
  func removeObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, observer: NSObject, keyPath: String) throws
}

protocol PigeonApiProtocolNSObject {
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String?, object objectArg: NSObject?, change changeArg: [KeyValueChangeKey: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiNSObject: PigeonApiProtocolNSObject  {
  unowned let pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSObject
  init(pigeonRegistrar: CLGeocoderLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSObject) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSObject?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: CLGeocoderLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.NSObject.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let addObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.NSObject.addObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let observerArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        let optionsArg = args[3] as! [KeyValueObservingOptions]
        do {
          try api.pigeonDelegate.addObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg, keyPath: keyPathArg, options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addObserverChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.geocoding_darwin.NSObject.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let observerArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg, keyPath: keyPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSObject and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSObject, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    }     else if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(()))
    }     else {
      let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
      let binaryMessenger = pigeonRegistrar.binaryMessenger
      let codec = pigeonRegistrar.codec
      let channelName: String = "dev.flutter.pigeon.geocoding_darwin.NSObject.pigeon_newInstance"
      let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(PigeonError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String?, object objectArg: NSObject?, change changeArg: [KeyValueChangeKey: Any?]?, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.geocoding_darwin.NSObject.observeValue"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, keyPathArg, objectArg, changeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
